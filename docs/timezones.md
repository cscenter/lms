### Особенности работы с таймзонами

Postgres хранит datetime как ::timestamptz, который перед сохранением конвертирует время в UTC, а возвращая - с учетом настроек соединения. 
Некоторые примеры поведения postgres можно увидеть разделом ниже, но по сути всю работу с часовыми поясами делает приложение, 
поэтому стоит сосредоточиться на поведении Django. 

```
In [1]: with connection.cursor() as cursor:
    cursor.execute('show timezone')
    row = cursor.fetchone()

In [2]: row
Out[2]: ('UTC',)
# Т.е. промежуточных конвертаций при перегоне дат из приложения в БД и обратно у нас нет. Django просто создаёт aware-объект c `tzinfo=UTC`. 
Postgres получает и отдаёт UTC метку.
```



   
Python поддерживает `tzinfo` для `time`, но Django тип `time` всегда хранит как naive и ничего не знает о часовом поясе. Postgres придерживается такого же мнения. 
Что насчёт `datetime`?

В настройках приложения выставлено `USE_TZ=True`, поэтому Django внутри использует timezone-aware объекты, где `tzinfo=pytz.UTC`. 
Например, утилита `django.utils.timezone.now`, которая используется для получения текущего времени, 
возвращает aware-объект - берётся локальное время сервера (часовой пояс MSK, в postgres может называться W-SU) и уже приводится к UTC.

По идее, мы всегда должны работать с aware-объектами на уровне приложения, иначе нельзя производить операции взятия разницы 
между объектами datetime (python просто не даст это сделать и выкинет ошибку), но могут возникать ситуации, 
когда мы работаем с naive объектом, который пытаемся сохранить в БД. 
Django в этом случае в лог пишет warning, добавляет к naive объекту таймзону, указанную в `TIME_ZONE`, делая его aware. 
Таймзона по-умолчанию это мск, поэтому если naive объект содержит время из Нск, то могут возникнуть некоторые проблемы в дальнейшем. 
Например, мы будем невовремя отправлять уведомление, ошибаясь при проверке, наступило ли время отправки. 
Rule of thumb - избавляться от всех warning'ов `received a naive datetime`. При преобразовании naive -> aware учитывать часовой пояс.
При этом есть важный момент, про который стоит знать и который нужно учитывать. 
Нельзя в лоб использовать метод `datetime.replace` для корректировки часового пояса в naive-объектах.
Дело в том, что он будет по-глупому использовать первую запись из tz data source. Пример такого источника:

```
# Zone  NAME            GMTOFF   RULES       FORMAT   [UNTIL]
Zone    Europe/Berlin   0:53:28  -           LMT      1893 Apr
                        1:00     C-Eur       CE%sT    1945 May 24 2:00
                        1:00     SovietZone  CE%sT    1946
                        1:00     Germany     CE%sT    1980
                        1:00     EU          CE%sT
```

С учетом структуры выше, рассмотрим как будет работать `replace`:

```
import pytz
from datetime import datetime
tz = pytz.timezone('Europe/Berlin')

>>> tz
<DstTzInfo 'Europe/Berlin' LMT+0:53:00 STD>

dt = datetime(2011, 1, 3, 18, 40)
result = tz.localize(dt)

>>> result.tzinfo
<DstTzInfo 'Europe/Berlin' CET+1:00:00 STD>

>>> dt.replace(tzinfo=tz)
datetime.datetime(2011, 1, 3, 18, 40, tzinfo=<DstTzInfo 'Europe/Berlin' LMT+0:53:00 STD>)

>>> result.tzinfo == tz
False
```

Т.е. как вывод - нужно использовать метод `localize`.

Всегда использовать `normalize` после арифметики с датами.

TODO: Ещё один пример возникающих проблем - создаём комментарий из Нск, на сайте отображаем дату создания - получаем время по МСК. Будет путать. 

TODO: Пока стратегия следующая - https://github.com/cscenter/site/issues/444 Если покажет свою жизнеспособность, то можно сюда перенести.
   
https://habrahabr.ru/post/273177/
https://habrahabr.ru/company/mailru/blog/242645/
http://asvetlov.blogspot.ru/2011/02/date-and-time.html


Рассмотрим ситуацию, когда можно схлопотать проблем (на примере создания interview из потока и слота):

* Берём stream.date и slot.time (время пусть будет 15:30). Они оба naive
* Цепляем их при помощи datetime.combine, получаем тоже naive-объект.
* Передаем его в форму InterviewForm. Она делает объект aware, но просто подставив tzinfo с московским часовым поясом, само время никак не меняет (dt.replace(tzinfo=tzmsk))
* Вызываем interview.date.strftime("%H:%M"). Получим 15:30
* Сохраняем собеседование. В БД получаем запись примерно как 2017-06-26 15:30:00+03. 
* В шаблонах эта дата показывается как 15:30, т.е. Django учтёт часовой пояс из настроек (скорее всего оттуда, а не из системной локали. TODO: проверить)
* Получим сохранённую модель из БД. interivew = Interview.objects.get(...). 
* Заново вызовем interview.date.strftime("%H:%M") Значение уже 12:30... Postgres хранить дату как UTC, получаем из БД тоже UTC, а это уже 12:30

Мораль - перед тем как пользоваться strftime, нужно учесть часовой пояс. Более общее утверждение - перед форматированием учесть часовой пояс.

Если хочется, чтобы postgres возвращал всё в UTC, нужно выполнить `SET SESSION timezone TO 'UTC';` для текущей сессии.


   
### Некоторые особенности работы postgres с датами

```
cscdb=> select '2014-04-04 20:00:00'::timestamptz;
      timestamptz
------------------------
 2014-04-04 20:00:00+04
(1 row) -- PG считает, что передано время без учета часового пояса. Берёт таймзону текущего соединения, на его основе конвертирует время в UTC. А выводит местное, с добавлением информации о часовом поясе, в котором отображает.

cscdb=> select '2014-04-04 20:00:00'::timestamptz at time zone 'UTC';
      timezone
---------------------
 2014-04-04 16:00:00
(1 row) -- как PG покажет время, если `show timezone` показывает пояс для UTC+0

cscdb=> select '2014-04-04 20:00:00'::timestamp;
      timestamp
---------------------
 2014-04-04 20:00:00
(1 row) -- Не показывает информацию о поясе, как и положено

cscdb=> select '2014-04-04 20:00:00'::timestamp at time zone 'UTC';
        timezone
------------------------
 2014-04-05 00:00:00+04
(1 row) -- В зоне UTC было 20:00, а наше местное на 4 часа больше. Его мы и видим.
```

### Как python отображает даты в консоли:

Из кода ниже можно сделать вывод, что время показывается локальное, с учетом часового пояса.


```
# Naive
In [1]: datetime(2017, 6, 26, 0, 0)
Out[1]: datetime.datetime(2017, 6, 26, 0, 0)

# Aware with UTC timezone
In [2]: datetime(2017, 6, 26, 0, 0, tzinfo=pytz.UTC)
Out[2]: datetime.datetime(2017, 6, 26, 0, 0, tzinfo=<UTC>)

# Incorrect aware with MSK timezone (call `normalize` to fix)
In [3]: datetime(2017, 6, 26, 0, 0, tzinfo=tz_msk)
Out[3]: datetime.datetime(2017, 6, 26, 0, 0, tzinfo=<DstTzInfo 'Europe/Moscow' LMT+2:30:00 STD>)

# Correct aware with MSK timezone
In [4]: tz_msk.localize(datetime(2017, 6, 26, 0, 0))
Out[4]: datetime.datetime(2017, 6, 26, 0, 0, tzinfo=<DstTzInfo 'Europe/Moscow' MSK+3:00:00 STD>)

# Convert previous datetime to UTC timezone
In [5]: tz_msk.localize(datetime(2017, 6, 26, 0, 0)).astimezone(pytz.UTC)
Out[5]: datetime.datetime(2017, 6, 25, 21, 0, tzinfo=<UTC>)
```


### Как быть с датами в админке Django

Django любое поле datetime по-умолчанию показывает с помощью `django.contrib.admin.widgets.SplitDateTimeWidget`.
Это wrapper над `django.forms.widget.SplitDateTimeWidget`, вся логика над датами лежит там. Нас интересует метод `decompress`, 
который разбивает значения `datetime` на составляющие. Внутри он использует следующий метод

```
def to_current_timezone(value):
    """
    When time zone support is enabled, convert aware datetimes
    to naive datetimes in the current time zone for display.
    """
    if settings.USE_TZ and value is not None and timezone.is_aware(value):
        current_timezone = timezone.get_current_timezone()
        return timezone.make_naive(value, current_timezone)
    return value
```

`make_naive` сначала локализует время до `current_timezone`, а затем убивает информацию о таймзоне (устанавливает `tzinfo=None`)
Т.е. хочу я этого или нет, на отображение времени в форме админки будет влиять выставленная таймзона.

Не знаю, насколько уместно использовать такую терминологию, но выставление таймзоны через `timezone.activate` похоже на coarse-grained решение, одна глобальная настройка. 
Хочется fine-grained решения, уметь скорректировать таймзону на уровне формы/поля формы.
# TODO: Подумать, можно ли это делать на уровне модели? Если, предположим, всё в UTC? Очевидно, что если текущее
Что делать на уровне формы/поля?

* Берём дату, которую Django нам любезно кастанула в aware-объект с таймзоной UTC (из предположения, что у нас стоит `TIME_ZONE='UTC'` в settings)
* Находим город, к которому относится текущая модель, у города берём таймзону.
* Перед сохранением в БД нужно сделать `.replace(tzinfo=city_tz)` и `city_tz.normalize()`. Можно ещё явно кастануть к UTC, либо проверить, что это делает Django за нас.
* Когда достали данные из БД - у нас время в UTC, нам нужно выполнить `astimezone(city_tz)` и `.replace(tzinfo=pytz.UTC)`
Если пользоваться методами Django, то это похоже на последовательность `localtime(value, timezone=city_tz)` и `make_naive(value, timezone=UTC)`

Возникает главный вопрос - а нужно ли нам `USE_TZ` в таком случае? В публичке оно нам мешает, 
т.к. уже нельзя бездумно использовать локализацию, если хотим всегда показывать локальное время для события.

В формах оно нам будет выставлять таймзону UTC, добавляя немного гемора при конвертации, но при работе с naive весь гемор есть по-прежнему.


Вопросы на обсуждение:
Как отображать даты? Единообразно, в зависимости от настроек пользователя? Или локальное время для события. 
Если второе, то что делать в случае, если у нас идёт микс событий? NSK/ MSK ??? Например, какая-то таблица. Да и возможно ли это?
Для логов какое время показывать? Если не UTC, то возрастает кол-во вычислений. :(
Показывать для часового пояса пользователя я не могу, потому что это влияет и на формы :(
для глобальных - показывать локальное нельзя. Иначе опять миллион вычислений.

Студент дат не вводит, а значит ему ок выставлять таймзону. Но если он не только студент?
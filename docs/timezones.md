### Особенности работы с таймзонами

Postgres хранит datetime как ::timestamptz, который перед сохранением конвертирует время в UTC, а возвращая - с учетом настроек соединения. 
Некоторые примеры поведения postgres можно увидеть разделом ниже, но по сути всю работу с часовыми поясами делает приложение, 
поэтому стоит сосредоточиться на поведении Django. 

```
In [1]: with connection.cursor() as cursor:
    cursor.execute('show timezone')
    row = cursor.fetchone()

In [2]: row
Out[2]: ('UTC',)
# Т.е. промежуточных конвертаций при перегоне дат из приложения в БД и обратно у нас нет. Django просто создаёт aware-объект c `tzinfo=UTC`. 
Postgres получает и отдаёт UTC метку.
```



   
Python поддерживает `tzinfo` для `time`, но Django тип `time` всегда хранит как naive и ничего не знает о часовом поясе. Postgres придерживается такого же мнения. 
Что насчёт `datetime`?

В настройках приложения выставлено `USE_TZ=True`, поэтому Django внутри использует timezone-aware объекты, где `tzinfo=pytz.UTC`. 
Например, утилита `django.utils.timezone.now`, которая используется для получения текущего времени, 
возвращает aware-объект - берётся локальное время сервера (часовой пояс MSK, в postgres может называться W-SU) и уже приводится к UTC.

По идее, мы всегда должны работать с aware-объектами на уровне приложения, иначе нельзя производить операции взятия разницы 
между объектами datetime (python просто не даст это сделать и выкинет ошибку), но могут возникать ситуации, 
когда мы работаем с naive объектом, который пытаемся сохранить в БД. 
Django в этом случае в лог пишет warning, добавляет к naive объекту таймзону, указанную в `TIME_ZONE`, делая его aware. 
Таймзона по-умолчанию это мск, поэтому если naive объект содержит время из Нск, то могут возникнуть некоторые проблемы в дальнейшем. 
Например, мы будем невовремя отправлять уведомление, ошибаясь при проверке, наступило ли время отправки. 
Rule of thumb - избавляться от всех warning'ов `received a naive datetime`. При преобразовании naive -> aware учитывать часовой пояс.
При этом есть важный момент, про который стоит знать и который нужно учитывать. 
Нельзя в лоб использовать метод `datetime.replace` для корректировки часового пояса в naive-объектах.
Дело в том, что он будет по-глупому использовать первую запись из tz data source. Пример такого источника:

```
# Zone  NAME            GMTOFF   RULES       FORMAT   [UNTIL]
Zone    Europe/Berlin   0:53:28  -           LMT      1893 Apr
                        1:00     C-Eur       CE%sT    1945 May 24 2:00
                        1:00     SovietZone  CE%sT    1946
                        1:00     Germany     CE%sT    1980
                        1:00     EU          CE%sT
```

С учетом структуры выше, рассмотрим как будет работать `replace`:

```
import pytz
from datetime import datetime
tz = pytz.timezone('Europe/Berlin')

>>> tz
<DstTzInfo 'Europe/Berlin' LMT+0:53:00 STD>

dt = datetime(2011, 1, 3, 18, 40)
result = tz.localize(dt)

>>> result.tzinfo
<DstTzInfo 'Europe/Berlin' CET+1:00:00 STD>

>>> dt.replace(tzinfo=tz)
datetime.datetime(2011, 1, 3, 18, 40, tzinfo=<DstTzInfo 'Europe/Berlin' LMT+0:53:00 STD>)

>>> result.tzinfo == tz
False
```

Т.е. как вывод - нужно использовать метод `localize`.

Всегда использовать `normalize` после арифметики с датами.

TODO: Ещё один пример возникающих проблем - создаём комментарий из Нск, на сайте отображаем дату создания - получаем время по МСК. Будет путать. 

TODO: Пока стратегия следующая - https://github.com/cscenter/site/issues/444 Если покажет свою жизнеспособность, то можно сюда перенести.
   
https://habrahabr.ru/post/273177/
https://habrahabr.ru/company/mailru/blog/242645/
http://asvetlov.blogspot.ru/2011/02/date-and-time.html


Рассмотрим ситуацию, когда можно схлопотать проблем (на примере создания interview из потока и слота):

* Берём stream.date и slot.time (время пусть будет 15:30). Они оба naive
* Цепляем их при помощи datetime.combine, получаем тоже naive-объект.
* Передаем его в форму InterviewForm. Она делает объект aware, но просто подставив tzinfo с московским часовым поясом, само время никак не меняет (dt.replace(tzinfo=tzmsk))
* Вызываем interview.date.strftime("%H:%M"). Получим 15:30
* Сохраняем собеседование. В БД получаем запись примерно как 2017-06-26 15:30:00+03. 
* В шаблонах эта дата показывается как 15:30, т.е. Django учтёт часовой пояс из настроек (скорее всего оттуда, а не из системной локали. TODO: проверить)
* Получим сохранённую модель из БД. interivew = Interview.objects.get(...). 
* Заново вызовем interview.date.strftime("%H:%M") Значение уже 12:30... Postgres хранить дату как UTC, получаем из БД тоже UTC, а это уже 12:30

Мораль - перед тем как пользоваться strftime, нужно учесть часовой пояс. Более общее утверждение - перед форматированием учесть часовой пояс.


   
### Некоторые особенности работы postgres с датами

```
cscdb=> select '2014-04-04 20:00:00'::timestamptz;
      timestamptz
------------------------
 2014-04-04 20:00:00+04
(1 row) -- PG считает, что передано время без учета часового пояса. Берёт таймзону текущего соединения, на его основе конвертирует время в UTC. А выводит местное, с добавлением информации о часовом поясе, в котором отображает.

cscdb=> select '2014-04-04 20:00:00'::timestamptz at time zone 'UTC';
      timezone
---------------------
 2014-04-04 16:00:00
(1 row) -- как PG покажет время, если `show timezone` показывает пояс для UTC+0

cscdb=> select '2014-04-04 20:00:00'::timestamp;
      timestamp
---------------------
 2014-04-04 20:00:00
(1 row) -- Не показывает информацию о поясе, как и положено

cscdb=> select '2014-04-04 20:00:00'::timestamp at time zone 'UTC';
        timezone
------------------------
 2014-04-05 00:00:00+04
(1 row) -- В зоне UTC было 20:00, а наше местное на 4 часа больше. Его мы и видим.
```
Proposal: Нужно вернуть поддержку стандартных джанговских permissions для модели User.

Мотивация: Это вернёт возможность использовать стандартную модель User со стандартным механизмом проверки 
прав доступа в `django.contrib.auth.backends.ModelBackend`, позволяя использовать код с существующим приложением, 
а главное - не навязывает кастомную модель пользователя и проверки прав доступа.
Сейчас кастомная модель User не даёт никаких явных преимуществ перед стандартной.

В кастомной модели User сейчас сломана поддержка `django.contrib.auth.models.PermissionsMixin` - 
были удалены `User.user_permissions` (можно легко вернуть) и кастомизирован RelatedManager для groups 
(была связь m2m позволяющая привязать permissions к модели Group, сейчас используется 1-to-many) - вернуть сложно


### Проверка прав доступа

Сейчас все Permissions можно разделить на 2 типа:

* Те, что добавляют приложения с помощью `auth.permissions.add_perm` на уровне кода.
* Стандартные права, которые генерирует Django и учитывает при доступе к админке (см `django.contrib.auth.models.Permission`)

Стандартный механизм Django для выдачи прав доступа 
пользователю (`django.contrib.auth.models.PermissionsMixin`) сейчас удалён, 
админка продолжает работать благодаря флагу `is_superuser`, который 
наделяет пользователя абсолютно всеми правами, авторизационные бэкенды даже 
не включаются в работу (см `django.contrib.auth.models.PermissionsMixin.has_perm`).

Это оказалось неудобно при проверке прав доступа на уровне приложения, когда 
доступ больше зависит от объекта, чем пользователя. Например, отзывы к курсу 
показываем только когда открыта регистрация на курс, нарушать этот инвариант
для суперпользователя (куратора) и показывать вкладку всегда нет смысла. 
На уровне предиката можно было бы кинуть исключение PermissionDenied, чтобы 
гарантировано запретить доступ, но до него не доходит дело, т.к. вызываются они бэкендом. 
В итоге, проверка на суперпользователя кастомизирована - если perm 
зарегистрирован в `auth.permissions.all_permissions`, то проверка должна 
происходить на уровне бэкенда(ов). В остальных случаях возвращаем True как и 
раньше, сохраняя работоспособность админки для суперпользователей.
Если стандартный Permission перекрыт каким-либо приложением - то это их дело, 
значит они хотят больше гарантий при выполнении действия, которых 
флаг `is_superuser` не может гарантировать.

FIXME: стоит ли запретить приложениям объявлять идентификатор права 
доступа для других приложений? Например, из приложения `users` позволять 
добавлять права `courses.*`
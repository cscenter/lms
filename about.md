# Про всё подряд

*Документ актуален на 9 апреля 2015 года.*

## Общая архитектура

Используется достаточно традиционный стек:

* PostgreSQL. Раньше был MySQL, но Postgres, особенно свежий, гораздо лучше и
умеет гораздо больше;
* Python 2. Третий питон не поддерживался, по крайней мере раньше, какой-то
частью используемых библиотек. Большая часть кода проекта должна быть совместима
с Python 3 без больших проблем;
* Django;
* uwsgi;
* nginx для обратного проксирования uwsgi и отдачи статики. Вся статика отдаётся
с очень большим TTL, для сache busting'а используются хеши файлов
(см. [ManifestStaticFilesStorage](https://docs.djangoproject.com/en/1.7/ref/contrib/staticfiles/#django.contrib.staticfiles.storage.ManifestStaticFilesStorage));
* немного модифицированный Bootstrap 3. Т.к. патчи накладывались прямо на файлы
Bootstrap'а, обновить его без боли не получится;
* jQuery + underscore.js;
* markdown, подсветка синтаксиса и latex рендерятся в браузере после загрузки,
всё это вместе называется в коде Ubertext (см. ниже).


## Сторонние сервисы

Сайт CSC использует ряд сторонних сервисов, которые описаны в этом разделе.

### AWS

Хостинг всего осуществляется на AWS, в Франкфуртской зоне (на сегодня это
ближайшая к РФ зона AWS). «Главный» ssh-ключ, с которым осуществляется
развёртывание, есть у Екатерины Лебедевой и у Сергея Лебедева. Сам аккаунт нужно
получить у администраторов JetBrains. Затраты по поддержке серверной
инфраструктуры несёт JetBrains, последняя договорённость была на сумму меньшую
или равную $75 в месяц. Текущие затраты несколько меньше, поэтому есть запас для
расширения инфраструктуры, если это будет необходимо. С вопросами можно
обратиться к Сергею Жукову, sergey.zhukov@jetbrains.com, или создать issue в
YouTrack'е JetBrains.

Действия, необходимые для развёртывания сайта на новом аккаунте, описаны в
`infrastructure/README.md`.

NB: очень желательно использовать двухфакторную авторизацию для входа в консоль
AWS.

### NewRelic

Для мониторинга производительности используется NewRelic. Аккаунт можно получить
у Екатерины Лебедевой и Сергея Лебедева. NewRelic даёт подробную статистику по
времени ответа uwsgi-сервера и по времени рендеринга у клиента, позволяя
оценивать среднюю производительность и видеть аномально медленные
страницы. Кроме того, у NewRelic'а есть настраиваемый alert о недоступности
страницы, что весьма удобно по сравнению с жалобами пользователей. В отличие от
упомянутого далее Sentry, этот alert внешний и срабатывает вне зависимости от
причины неработоспосбности сайта — например, при отказе NS-серверов.

На текущий момент используется бесплатный Light аккаунт. Pro ощутимо удобнее
(например, позволяет автоматически собирать трассы медленных транзакций), но
дорог и на сегодня договориться о бесплатном аккаунте для образовательного
учреждения не удалось (возможно, стоит попробовать ещё раз).

### Sentry

Sentry — сервис, собирающий стектрейсы ошибок на сервере и в браузере
клиента. Аккаунт можно получить у Екатерины Лебедевой и Сергея Лебедева. Прямо
сейчас проблемой является очень большое количество ошибок из браузера, связанное
с нестабильной работой CDN (подробнее об этом ниже), поэтому их фильтрация или
(предпочитетельно) решение необходимо в среднесрочной перспективе.

Используется бесплатный аккаунт, т.к. его лимитов, вроде бы, хватает.

### Travis

Для CI используется приватный Travis CI, автоматически собирающий каждый push в
GitHub-репозиторий (можно открыть кликом на бадж в README.md в корне). Вроде бы
не требует отдельного аккаунта, поскольку использует авторизацию
GitHub'а. Приватный аккаунт предоставлен Travis CI бесплатно для
образовательного учреждения (возможно, стоит их порекламировать где-нибудь).


## Обратить внимание

В этом разделе описывается несколько моментов, которые стоит держать в голове.

### SSL-cертификат

Сейчас используется бесплатный сертификат на год от
[StartSSL.org](https://startssl.org) **с датой окончания 28 января 2016**. Очень
важным является обновление сертификата *до* этой даты, т.к. отключить TLS
*быстро* будет нельзя из-за HSTS (см. ниже). В середине 2015 должен заработать
[Let's Encrypt](https://letsencrypt.org/), вероятно, они будут более удобными,
чем StartSSL.

Копия приватного ключа сертификата есть у Екатерины Лебедевой и Сергея Лебедева.

NB: без TLS пароли пользователей передаются по сети в открытом виде, что
недопустимо.

### HSTS

[HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) —
принципиально важный компонент развёртывания TLS сегодня, поскольку без него
становится возможным
[SSL stripping](https://en.wikipedia.org/wiki/Moxie_Marlinspike#Notable_research). В
связи с этим nginx отдаёт хедер Strict-Transport-Security с таймаутом в 6
месяцев. Это не должно быть проблемой, если всё хорошо, но делает проблематичным
«легитимное» отключение TLS.

### Домен и регистратор

Регистратором домена compscicenter.ru является RU-CENTER, владельцем — компания
Яндекс. Для домена включено автопродление, поэтому с ним не должно быть
проблем. Помочь решить проблемы с регистратором может помочь Евгения Куликова
(lilosea@yandex-team.ru), конкретный человек, которым занимался изменениями —
Татьяна Бахаревская (tvt@yandex-team.ru).

В качестве NS-cерверов сейчас используется Route53 на AWS, соответственно,
управление записями осуществляется из панели AWS.

### Бекапы на S3

Каждую ночь в 4:00 по серверному времени снимается полный бекап базы и media
(залитых пользователями файлов). Бекап заливается на S3 в папку с hostname и
временем; для соответствующего bucket'а настроен TTL в 30 дней, поэтому в любой
момент времени доступны посуточные бекапы за последний месяц.


## KPI

Подчеркну отдельно два важных KPI, падения которых стоит избегать.

### Время ответа сервера

Есть шесть разных способов, которыми можно замерить время ответа сервера:

1. локальное тестирование с Django Debug Toolbar'ом. Наиболее грубый способ, но
позволяет обнаружить вырожденные случаи;
2. логи uwsgi, в которых пишется время ответа на конкретный запрос. Хороший
способ убедиться в адекватности цифр, которые показывает NewRelic. Естественно, при этом
совершенно не учитывается сетевая задержка и задержка от nginx'а;
3. access-логи nginx (обычно отключены);
4. web transactions response time в разделе servers на NewRelic. Цифры здесь
должны примерно совпадать с логами uwsgi, но их гораздо удобнее
просматривать. **Latency здесь нужно стараться держать меньшей, чем 100
миллисекунд**, т.к. ещё есть сетевые задержки;
5. browser page load time в разделе browser на NewRelic. Это суммарное время
загрузки страницы, учитывающее загрузку всех ресурсов и работу JS. **Числа в этом
разделе желательно удерживать в диапазоне «до 2–3 секунд»** — страница
отображается в современных браузерах немного раньше, чем оканчивается её
загрузка, но суммарное время не должно быть слишком большим.
6. time to first byte для .html в табе network в dev tools любимого
браузера. **В условиях идеальной сети (вроде офисной в JB) это число не должно
превышать 200 миллисекунд**, по крайней мере для часто используемых страниц
вроде страницы курса.

### Отсутствие ошибок

Здесь всё гораздо проще: в нормальном режиме работы Sentry не должен сообщать об
ошибках и варнингах сервера вообще. Дополнительно желательно проверять, что
репорты об ошибках успешно уходят на Sentry в логе uwsgi (если при отправке
что-то идёт не так, это оказывается отражено в логах).


## Разное

### Ubereditor/ubertext

Эти названия используются в коде и иногда в документации. Под ними
подразумевается редактор, используемый для ввода многострочного текста с
поддержкой markdown'а, подсветки кода и latex'а, и сам такой текст. С точки
зрения Django, Ubereditor это просто widget для TextField'а, представляющий из
себя настроенный [EpicEditor](http://epiceditor.com/); Ubertext это класс на
div'е, который использутся JS'ом для рендеринга при событии DOM ready.

### Персистентность комментариев

Комментарии к заданиям бывают достаточно длинными и очень неприятно терять их
из-за случайно закрытой вкладки или ошибки сети. Чтобы избежать этого, был
добавлен механизм «персистентных комментариев», состоящий из двух частей:
регулярное сохранение комментария в HTML5 localStorage (это просто и
поддерживается в EpicEditor'е) и инвалидация сохранённого комментария *в случае
успешной его записи в БД*. Последняя часть важна, т.к. большинство существующих
решений удаляют сохранённый комментарий *при отправке формы*, что делает
неизбежной потерю комментария в случае сетевой ошибки или ошибки сервера.

Нетривиальность последней части заключается в том, что традиционная
request-reply модель подразумевает, что статус сохранения комментария известен
только конкретному хендлеру, отвечающему браузеру редиректом. Так как мы не
можем исполнять JS во время редиректа, нужно как-то сообщить браузеру, что
запись прошла успешно, «через» редирект. Одним из разумных вариантов выглядит
установка cookie при редиректе с последующим чтением её из JS, но в хроме есть
баг, из-за которого он игнорирует Set-Cookie на редиректе. Поэтому был
реализован следующий подхак:

* если сохранение комментария успешно (это определяется в `form_valid`), часть
его хеша (уникальная для конкретного текста) сохраняется в джанговый кеш (общий
для всех воркеров) под определённым ключём с небольшим TTL;
* на страницу с «персистентным» комментарием в inline JS подставляется строчка с
кусочками хешей;
* в JS проверяется, не совпадает ли хеш сохранённого комментария с уже
существующими, и если да, то он удаляется из localStorage.

В ретроспективе видится два возможных улучшения:

* использование сессии вместо общего кеша;
* переход на исключительно AJAX отправку комментариев, что полностью решит эту
проблему, т.к. в JS мы будем знать, состоялась ли запись.

### Отправка по Ctrl+Enter

Для форм, которые часто отправляются (комментарии к заданиям, ведомость)
добавлена поддержка отправки формы по Ctrl+Enter. Это удобное неявное
соглашение, которое используется много где, и его лучше не потерять при
рефакторингах и переписываниях.


## Идеи, планы, мысли

В этом разделе описаны идеи и планы для дальнейшего развития проекта. Здесь
будет меньше структуры, так как это скорее brain dump от предыдущего
разработчика. Этот раздел призван дополнить issues в репозитории; там, где это
уместно, будут даны ссылки на существующие issue.

### Решение проблем с загрузкой JS

Underscore, jQuery, Raven и MathJax сейчас загружаются с CDN, что считается
«стандартной практикой». К сожалению, в Sentry можно видеть около десятка ошибок
в день вида «jQuery не найден», причина которых — сетевая ошибка при загрузке с
CDN, которая, тем не менее, не мешает выполняться остальному JS'у. Каждое такое
событие — временно сломанная страница у пользователя, исправляющающаяся «сама
собой» при перезагрузке. Возможные решения по мере увеличения «инвазивности»:

* не использовать CDN, сложив всё в локальные assets, как есть;
* то же, но используя тот или иной asset pipeline для объединения файлов;
* перейти на ClojureScript и соответствующий asset pipeline (Google
Closure). Учитывая поддержку
[Google Closure Modules](http://swannodette.github.io/2015/02/23/hello-google-closure-modules/),
это достаточно адекватный вариант с, вероятно, наименьшим итоговым весом
.js-файла.

Тонкий момент: MathJax, скорее всего, должен остаться внешней зависимостью по
нескольким причинам:

* размер библиотеки;
* разные варианты её конфигурации и свой механизм разрешения зависимостей;
* по большому счёту, опциональность для рендеринга страницы. По сравнению с
jQuery, ошибка загрузки которого приводит к неработоспосбности практически
всего JS-кода, ошибка загрузки MathJax некритична.

Из этого следует необходимость очень defensive кода вокруг вызовов MathJax,
т.к. его может не быть (`undefined is not a function`).

### Task queue

Релевантный issue, там всё написано: https://github.com/cscenter/site/issues/77

### Ускорение рендеринга шаблонов

Если NewRelic не врёт, львиную долю времени ответа сейчас пожирает питон, а не
БД. Возможно, проблема в шаблонах и, в частности, в логике рендеринга
меню. Релевантный код находится в описании template tag'а `current`. Сейчас на
каждый экземпляр этого тега запускается обход небольшого дерева; может быть, в
питоне это медленнее, чем предполагалось изначально.

### Более годные формы

Релевантный issue: https://github.com/cscenter/site/issues/74

### Переход на AsciiDoc(tor)

Изначальной мотивацией для рендеринга markdown'а на клиентской стороне была его
одинаковость при предпросмотре в браузере и при рендеринге сохранённого
текста. Одна из проблем markdown'а — отсутствие стандарта, поэтому
markdown-процессоры на JS'е и Python'е будут выдавать разную разметку в краевых
случаях.

С течением времени это решение показало свою несостоятельность. Основная
проблема — эстетическая: страница резко изменяется после загрузки, при этом до
изменения текст напоминает кашу (markdown, помещённый в div, не сохраняет
переносы строк). Кроме того, можно предположить, что страдает индексация
поисковыми системами.

Другая проблема markdown'а — неспецифицированность сочетания Latex'а и
markdown'а, особенно в присутствии вставок кода (текущий код использует пару
эвристик, которые всё равно иногда ломаются). Эта ситуация
[вряд ли изменится](http://talk.commonmark.org/t/mathjax-extension-for-latex-equations/698).

Принципиальным решением обеих проблем был бы переход на предпросмотр с помощью
AJAX-запроса и рендеринга на сервере, как это делает GitHub (что позволяет
использовать рендеринг только на сервере), и использование
[AsciiDoc](http://asciidoctor.org)'а (в котором строго специфицированы блоки для
Latex'а). В этом случае любое поле с Ubertext'ом превращается в пару
TextField'ов — с исходной разметкой и с отрендерённой.

Некоторая проблема AsciiDoctor'а (видимо, лучшего рендера AsciiDoc'а)
заключается в том, что он написан на Ruby и существует в вариантах для JVM
(JRuby) и JS (трансляция в JS). Вариант, который был частично реализован —
обёртка AsciiDoctorJ (вариант для JVM)
[тривиальным HTTP-интерфейсом](https://github.com/cscenter/marker). Время
рендеринга средних размеров AsciiDoc'а измеряется миллисекундами, что позволяет
производить рендеринг синхронно с помощью сигналов. Для предпросмотра можно
просто реверс-проксировать этот HTTP-интерфейс с помощью nginx'а либо Django (во
втором варианте можно осуществлять контроль доступа).

Дополнительным плюсом AsciiDoctor'а является его частичная обратная
совместимость с Markdown'ом, что позволяет облегчить процесс миграции на
AsciiDoc.

Другим, немного менее радикальным вариантом, является использование node.js на
сервере и того же markdown-процессора на клиенте. В этом случае хорошим
кандидатом на роль основного процессора является
[remarkable](https://github.com/jonschlinkert/remarkable).

### Сайт Клуба

Релевантный issue: https://github.com/cscenter/site/issues/85

### Multiple upload

Сейчас достаточно неудобно прикладывать несколько файлов к чему-либо; кроме
того, код, связанный с приложением файлов, дублируется в нескольких местах
(модель для файла, M2M отношение, несколько view). По всей видимости, наиболее
адекватное решение — вставить функционал загрузки нескольких файлов в Ubereditor
и делать это с помощью горки JS и AJAX-запросов к одному и тому же endpoint'у.

Тонкое место: куда заливать файлы?

* если на сам сервер, это будет означать потребление EBS (что относительно
недёшево), плюс текущая схема бекапа не будет работать (нужно отказываться от
ежедневного бекапа media либо переходить на велосипедные инкрементальные
бекапы);
* если заливать на S3 (практически неограниченный объём, не нужны бекапы из-за
высокого уровня надёжности S3), возникает проблема с контролем доступа.

Релевантный issue: https://github.com/cscenter/site/issues/74

### Редизайн

Релевантный issue: https://github.com/cscenter/site/issues/83

### oEmbed

В репозитории есть
[относительно старый Pull Request](https://github.com/cscenter/site/pull/54) c
миграцией на [oEmbed](http://www.oembed.com/) в качестве механизма встраивания
видео и слайдов. К сожалению, в PR есть неразрешённые проблемы, он сихронный
(см. выше о Task queue), а мерж его нетривиален. Возможно, нужно переделать
схожую логику ещё раз.

### Миграция на SES

Прямо сейчас почта отправляется с обычного пользовательского ящика на
Яндексе. При этом невозможно получить информацию по отказам и отправкам писем в
спам, а сам процесс отправки достаточно небыстрый. Вероятно, более хорошим
вариантом будет Amazon SES с его инфраструктурой для этого и API.

### Индексы для поиска имён студентов

Сейчас в «кураторской» части есть поиск студентов по имени. Для того, чтобы
поиск был гибким (по префиксу имени или фамилии) и одновременно можно было
построить индекс, используется полнотекстовый поиск по композитной
колонке. Прямо сейчас он достаточно быстрый даже с fullscan'ом, но если это
станет проблемой, ключевые слова для поиска — GIN-index и GiST-index.

### BREACH

Прямо сейчас nginx сконфигурирован так, что TLS сочетается с
gzip-компрессией. Это сочетание создаёт возможность
[BREACH-атаки](http://breachattack.com/). Это открытая проблема и уязвимость;
как решить её лучшим образом, неочевидно. Возможно, стоит отключить
gzip-компрессию для реверс-прокси (померив изменение скорости загрузки из-за
этого) и/или добавить элемент случайной длины в ответы (что замедляет
BREACH-атаку, но не исключает её полностью).

### Более лучшие статичные страницы

Сейчас в проекте существует приложение `textpages`. В нём есть набор заранее
записанных в миграциях (и участвующих в меню) страниц с моделью `Textpage` и
набор «дополнительных» страниц `CustomTextpage`, которые можно создавать из
админки, но на которые нельзя ссылаться из меню. На сайте Клуба статических
страниц будто бы больше и для них нужна интернационализация, поэтому отдельным
перспективным направлением выглядит улучшение приложения `textpages`:

* AsciiDoc как более мощный язык разметки (см. выше);
* статический рендеринг на сервере (сейчас многие из этих страниц описаны в
HTML'е из-за задержки рендеринга при загрузке страницы);
* произвольный URL из незанятых в основном urlconf'е (здесь требуется достаточно
нетривиальная проверка на отсутствие clash'ей);
* редактирование отдельным UpdateView вместо админки.

import logging

from django.conf import settings
from django.db.models import Q, Case, When, PositiveSmallIntegerField
from django.http import Http404

from courses.models import Course

logger = logging.getLogger(__name__)


# Don't bind a course lookup with `request.site` if set to False.
COURSE_FRIENDLY_URL_USE_SITE = getattr(settings, "COURSE_FRIENDLY_URL_USE_SITE", True)


class CourseURLParamsMixin:
    """
    This mixin helps to retrieve course record based on friendly URL
    generated by `settings.RE_COURSE_URI` and `request.branch`.
    Returns 404 if course is not found or attaches it to the view
    instance attributes.

    Natural key for a course is [course_slug, semester, branch], e.g.
    `/courses/spring-2018/python/spb/example.com/`. It means to retrieve unique
    course record without PK's we need:
        * semester type + semester year (uniquely identifies course semester)
        * course slug
        * branch code + site domain (uniquely identifies branch)

    Assumes that `settings.RE_COURSE_URI` doesn't provide **site domain**
    and **branch code** is optional. **branch code** should follow
    `core.middleware.BranchViewMiddleware` conventions to set or override
    `request.branch` value, this mixin doesn't use URL-param value directly.

    if **branch code** is omitted course lookup relies on `request.branch` value
    set by `core.middleware.CurrentBranchMiddleware`.

    If **branch code** is provided, two options are available:
        * get any course with **branch code** without guarantee that this course
        is unique
        * Attach request to the current site.
    """
    def setup(self, request, *args, **kwargs):
        # TODO: move to RequestBranchRequired mixin?
        if not hasattr(request, "branch"):
            logger.error(f"{self.__class__} needs `request.branch` value")
            # request.branch = None
        super().setup(request, *args, **kwargs)

        same_branch = Q(main_branch=self.request.branch)
        same_site = Q(main_branch__site=self.request.site)
        courses = list(self.get_course_queryset()
                       .available_in(self.request.branch)
                       .filter(main_branch__code=self.request.branch.code)
                       .annotate(priority=Case(
                           When(same_branch, then=2),
                           When(same_site, then=1),
                           default=0,
                           output_field=PositiveSmallIntegerField()
                       ))
                       .order_by('-priority', 'pk'))
        if not courses:
            raise Http404

        self.course: Course = courses[0]

    def get_course_queryset(self):
        """
        Returns queryset for the course based on request URL params
        """
        return (Course.objects
                .filter(semester__type=self.kwargs['semester_type'],
                        semester__year=self.kwargs['semester_year'],
                        meta_course__slug=self.kwargs['course_slug'])
                .select_related('meta_course', 'semester'))

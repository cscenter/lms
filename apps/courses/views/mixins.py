import logging

from django.conf import settings
from django.db.models import Q
from django.http import Http404, HttpResponseNotFound
from django.shortcuts import get_object_or_404

from core.models import Branch
from courses.models import Course

logger = logging.getLogger(__name__)


# Don't bind a course lookup with `request.site` if set to False.
COURSE_FRIENDLY_URL_USE_SITE = getattr(settings, "COURSE_FRIENDLY_URL_USE_SITE", True)


class CourseURLParamsMixin:
    """
    This mixin helps to retrieve course record based on friendly URL
    generated by `settings.RE_COURSE_URI` and `request.branch`.
    Returns 404 if course is not found or attaches it to the view
    instance attributes.

    Natural key for a course is [course_slug, semester, branch], e.g.
    `/courses/spring-2018/python/spb/example.com/`. It means to retrieve unique
    course record without PK's we need:
        * semester type + semester year (uniquely identifies course semester)
        * course slug
        * branch code + site domain (uniquely identifies branch)

    Assumes that `settings.RE_COURSE_URI` doesn't provide **site domain**
    and **branch code** is optional.

    if **branch code** is omitted course lookup relies on `request.branch` value
    set by `core.middleware.SubdomainBranchMiddleware`.

    If **branch code** is provided, two options are available:
        * get any course with **branch code** without guarantee that this course
        is unique
        * Attach request to the current site.
    """
    def setup(self, request, *args, **kwargs):
        """
        sets `branch` attribute to request object based on
        `request.site` and `branch_code_request` view keyword argument.

        Will override `request.branch` value set by `SubdomainBranchMiddleware`
        if both are included (view middleware is called later in
        the middleware chain)

        Two named view arguments are required for the middleware to set
        `branch` attribute to the request object:
        branch_code_request: str - should be empty for the default branch code
        branch_trailing_slash: str - "/" or empty in case of default branch code
        """
        branch_code = kwargs.get("branch_code_request", None)
        if branch_code is not None:
            slash = kwargs.get("branch_trailing_slash", None)
            if slash is not None:
                # /aaa//bbb case
                if not branch_code and slash:
                    raise Http404
                # /aa/xxxbb or /aa/xxxcbb cases, where `xxx` is a branch code
                # and `c` is invalid trailing slash value
                elif branch_code and (not slash or slash != "/"):
                    raise Http404
                elif not branch_code:
                    branch_code = settings.DEFAULT_BRANCH_CODE
                try:
                    request.branch = Branch.objects.get_by_natural_key(
                        branch_code, request.site.id)
                except Branch.DoesNotExist:
                    raise Http404

        # TODO: move to RequestBranchRequired mixin?
        if not hasattr(request, "branch"):
            logger.error(f"{self.__class__} needs `request.branch` value")
            # request.branch = None
        super().setup(request, *args, **kwargs)

        if COURSE_FRIENDLY_URL_USE_SITE:
            course = self._get_course_by_branch_id()
        else:
            courses = list(self.get_course_queryset()
                           .filter(main_branch__code=self.request.branch.code)
                           .order_by())
            if not courses:
                raise Http404
            for c in courses:
                if c.main_branch_id == self.request.branch.id:
                    course = c
                    break
            else:
                course = courses[0]
        self.course: Course = course

    def _get_course_by_branch_id(self):
        return get_object_or_404(self.get_course_queryset()
                                 .available_in(self.request.branch))

    def get_course_queryset(self):
        """
        Returns queryset for the course based on request URL params
        """
        return (Course.objects
                .filter(semester__type=self.kwargs['semester_type'],
                        semester__year=self.kwargs['semester_year'],
                        meta_course__slug=self.kwargs['course_slug'])
                .select_related('meta_course', 'semester'))

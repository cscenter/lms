import logging

from django.conf import settings
from django.db.models import Q
from django.http import Http404
from django.shortcuts import get_object_or_404

from courses.models import Course

logger = logging.getLogger(__name__)


# Don't bind a course lookup with `request.site` if set to False.
COURSE_FRIENDLY_URL_USE_SITE = getattr(settings, "COURSE_FRIENDLY_URL_USE_SITE", True)


class CourseURLParamsMixin:
    """
    This mixin helps to retrieve course record based on friendly URL
    generated by `settings.RE_COURSE_URI` and `request.branch`.
    Returns 404 if course is not found or attaches it to the view
    instance attributes.

    Natural key for a course is [course_slug, semester, branch], e.g.
    `/courses/spring-2018/python/spb/example.com/`. It means to retrieve unique
    course record without PK's we need:
        * semester type + semester year (uniquely identifies course semester)
        * course slug
        * branch code + site domain (uniquely identifies branch)

    Assumes that `settings.RE_COURSE_URI` doesn't provide **site domain**
    and **branch code** is optional. **branch code** should follow
    `core.middleware.BranchViewMiddleware` conventions to set or override
    `request.branch` value, this mixin doesn't use URL-param value directly.

    if **branch code** is omitted course lookup relies on `request.branch` value
    set by `core.middleware.CurrentBranchMiddleware`.

    If **branch code** is provided, two options are available:
        * get any course with **branch code** without guarantee that this course
        is unique
        * Attach request to the current site.
    """
    def setup(self, request, *args, **kwargs):
        # TODO: move to RequestBranchRequired mixin?
        if not hasattr(request, "branch"):
            logger.error(f"{self.__class__} needs `request.branch` value")
            # request.branch = None
        super().setup(request, *args, **kwargs)

        if COURSE_FRIENDLY_URL_USE_SITE:
            course = self._get_course_by_branch_id()
        else:
            courses = list(self.get_course_queryset()
                           .filter(branch__code=self.request.branch.code)
                           .order_by())
            if not courses:
                raise Http404
            for c in courses:
                if c.branch_id == self.request.branch.id:
                    course = c
                    break
            else:
                course = courses[0]
        self.course: Course = course

    def _get_course_by_branch_id(self):
        return get_object_or_404(self.get_course_queryset()
                                 .available_in(self.request.branch.pk))

    def get_course_queryset(self):
        """
        Returns queryset for the course based on request URL params
        """
        return (Course.objects
                .filter(semester__type=self.kwargs['semester_type'],
                        semester__year=self.kwargs['semester_year'],
                        meta_course__slug=self.kwargs['course_slug'])
                .select_related('meta_course', 'semester'))
